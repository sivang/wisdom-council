"""
wisdom-council - Bedrock Agent Action Handler
Generated by: bedsheet deploy --target aws

Simple handler using only standard library (no external dependencies).
"""
import logging
import json
import boto3
import os

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Bedrock Runtime client for delegate action
bedrock_runtime = boto3.client('bedrock-agent-runtime', region_name='eu-central-1')


def delegate(agent_name: str = None, task: str = None, delegations: str = None) -> str:
    """Delegate task(s) to collaborator agent(s). Use agent_name+task for single delegation, or delegations array for parallel."""

    # Map collaborator names to their agent/alias ARNs (from environment variables)
    collaborators = {}
    collaborators["Sage"] = {
        "agent_id": os.environ.get("COLLABORATOR_SAGE_AGENT_ID"),
        "alias_id": os.environ.get("COLLABORATOR_SAGE_ALIAS_ID"),
    }
    collaborators["Oracle"] = {
        "agent_id": os.environ.get("COLLABORATOR_ORACLE_AGENT_ID"),
        "alias_id": os.environ.get("COLLABORATOR_ORACLE_ALIAS_ID"),
    }

    def invoke_single(agent_name: str, task: str) -> str:
        """Invoke a single collaborator agent."""
        logger.info(f"Delegating to {agent_name}: {task}")

        if agent_name not in collaborators:
            return f"Unknown collaborator: {agent_name}. Available: {list(collaborators.keys())}"

        collab = collaborators[agent_name]

        try:
            # Invoke collaborator agent via Bedrock
            response = bedrock_runtime.invoke_agent(
                agentId=collab["agent_id"],
                agentAliasId=collab["alias_id"],
                sessionId=f"delegate-{agent_name}",
                inputText=task
            )

            # Collect response from event stream
            result = ""
            for event in response['completion']:
                if 'chunk' in event:
                    chunk = event['chunk']
                    if 'bytes' in chunk:
                        result += chunk['bytes'].decode('utf-8')

            return result

        except Exception as e:
            logger.exception(f"Failed to delegate to {agent_name}")
            return f"Error delegating to {agent_name}: {str(e)}"

    # Handle parallel delegation with delegations parameter
    if delegations:
        logger.info(f"Parallel delegation requested: {delegations}")
        # Parse delegations string - Bedrock sends it as a string representation
        # Format: "[{task=..., agent_name=Sage}, {task=..., agent_name=Oracle}]"
        import re

        # Extract individual delegation dicts
        pattern = r'\{([^}]+)\}'
        matches = re.findall(pattern, delegations)

        results = []
        for match in matches:
            # Parse key=value pairs
            pairs = {}
            for pair in match.split(', '):
                if '=' in pair:
                    key, value = pair.split('=', 1)
                    pairs[key.strip()] = value.strip()

            if 'agent_name' in pairs and 'task' in pairs:
                agent = pairs['agent_name']
                task_text = pairs['task']
                result = invoke_single(agent, task_text)
                results.append(f"{agent}: {result}")

        return "\n\n".join(results)

    # Handle single delegation
    elif agent_name and task:
        return invoke_single(agent_name, task)

    else:
        return "Error: Must provide either (agent_name + task) or delegations parameter"



# Action mapping
ACTIONS = {
    "delegate": delegate,
}


def lambda_handler(event: dict, context) -> dict:
    """Handle Bedrock Agent action group invocations.

    Event structure:
    {
        "actionGroup": "action_group_name",
        "apiPath": "/action_name",
        "httpMethod": "POST",
        "parameters": [...],
        "requestBody": {...}
    }
    """
    logger.info(f"Received event: {json.dumps(event)}")

    # Extract action name from API path
    api_path = event.get("apiPath", "")
    action_name = api_path.strip("/")

    if action_name not in ACTIONS:
        return {
            "messageVersion": "1.0",
            "response": {
                "actionGroup": event.get("actionGroup"),
                "apiPath": api_path,
                "httpMethod": event.get("httpMethod"),
                "httpStatusCode": 404,
                "responseBody": {
                    "application/json": {
                        "body": f"Action not found: {action_name}"
                    }
                }
            }
        }

    # Extract parameters from requestBody or parameters
    params = {}
    if "requestBody" in event:
        # New format: requestBody with properties array
        request_body = event["requestBody"]
        if "content" in request_body:
            content = request_body["content"]
            if "application/json" in content:
                json_content = content["application/json"]
                # Bedrock sends properties as an array, not a dict
                if "properties" in json_content:
                    for prop in json_content["properties"]:
                        params[prop["name"]] = prop["value"]
                else:
                    # If it's already a dict (shouldn't happen with Bedrock)
                    params = json_content
    else:
        # Legacy format: parameters array
        for param in event.get("parameters", []):
            params[param["name"]] = param["value"]

    # Execute action
    try:
        action_fn = ACTIONS[action_name]
        result = action_fn(**params)

        return {
            "messageVersion": "1.0",
            "response": {
                "actionGroup": event.get("actionGroup"),
                "apiPath": api_path,
                "httpMethod": event.get("httpMethod"),
                "httpStatusCode": 200,
                "responseBody": {
                    "application/json": {
                        "body": result
                    }
                }
            }
        }
    except Exception as e:
        logger.exception("Action failed")
        return {
            "messageVersion": "1.0",
            "response": {
                "actionGroup": event.get("actionGroup"),
                "apiPath": api_path,
                "httpMethod": event.get("httpMethod"),
                "httpStatusCode": 500,
                "responseBody": {
                    "application/json": {
                        "body": f"Error: {str(e)}"
                    }
                }
            }
        }