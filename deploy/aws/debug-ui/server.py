"""
wisdom-council - Bedrock Agent Debug Server
Generated by: bedsheet generate --target aws

FastAPI server that proxies to AWS Bedrock Agent and transforms
responses to Bedsheet-compatible SSE events for the debug UI.

Configuration via environment variables:
  BEDROCK_AGENT_ID      - Agent ID from CDK deployment
  BEDROCK_AGENT_ALIAS   - Agent Alias ID (default: TSTALIASID for draft)
  AWS_REGION            - AWS region (default: eu-central-1)
"""
import json
import os
import uuid
from typing import AsyncGenerator

import boto3
from fastapi import FastAPI
from fastapi.responses import StreamingResponse, HTMLResponse
from pydantic import BaseModel


# Agent configuration from environment (connects to first agent in chain)
AGENT_ID = os.environ.get("BEDROCK_AGENT_ID", "YOUR_AGENT_ID")
AGENT_ALIAS_ID = os.environ.get("BEDROCK_AGENT_ALIAS", "TSTALIASID")
REGION = os.environ.get("AWS_REGION", "eu-central-1")

app = FastAPI(title="wisdom-council Debug UI")


class InvokeRequest(BaseModel):
    """Request body for agent invocation."""
    message: str
    session_id: str | None = None


def get_bedrock_client():
    """Get Bedrock Agent Runtime client."""
    return boto3.client('bedrock-agent-runtime', region_name=REGION)


def extract_thinking_from_raw_response(raw_response: dict) -> list[str]:
    """
    Extract all thinking/reasoning content from modelInvocationOutput.rawResponse.

    Bedrock stores thinking in multiple places within the raw response:
    1. reasoningContent.reasoningText.text - Extended thinking blocks
    2. Leading text blocks before toolUse - Pre-action reasoning

    Args:
        raw_response: The rawResponse dict from modelInvocationOutput

    Returns:
        List of thinking text strings found in the response
    """
    thinking_texts = []

    if 'content' not in raw_response:
        return thinking_texts

    try:
        # The content is a JSON string that needs to be parsed
        content_str = raw_response['content']
        if isinstance(content_str, str):
            content_data = json.loads(content_str)
        else:
            content_data = content_str

        # Navigate to the message content array
        # Structure: {"output": {"message": {"content": [...]}}}
        message_content = (
            content_data.get('output', {})
            .get('message', {})
            .get('content', [])
        )

        if not isinstance(message_content, list):
            return thinking_texts

        for block in message_content:
            if not isinstance(block, dict):
                continue

            # Source 1: Plain text blocks (often contain thinking before tool calls)
            if block.get('text') and not block.get('toolUse'):
                text = block['text'].strip()
                if text:
                    thinking_texts.append(text)

            # Source 2: reasoningContent.reasoningText.text (extended thinking)
            reasoning_content = block.get('reasoningContent')
            if reasoning_content and isinstance(reasoning_content, dict):
                reasoning_text = reasoning_content.get('reasoningText', {})
                if isinstance(reasoning_text, dict) and reasoning_text.get('text'):
                    text = reasoning_text['text'].strip()
                    if text:
                        thinking_texts.append(text)

    except (json.JSONDecodeError, TypeError, KeyError) as e:
        # Log but don't fail - raw response parsing is best-effort
        pass

    return thinking_texts


async def stream_bedrock_events(
    message: str,
    session_id: str
) -> AsyncGenerator[str, None]:
    """
    Invoke Bedrock agent and transform response to Bedsheet SSE events.

    Handles:
    - Text chunks from agent response
    - Thinking/rationale traces
    - Action group tool calls (Lambda functions)
    - Sub-agent collaborator invocations (multi-agent)
    """
    client = get_bedrock_client()

    # Emit session event
    yield f"data: {json.dumps({'type': 'session', 'session_id': session_id})}\n\n"

    try:
        response = client.invoke_agent(
            agentId=AGENT_ID,
            agentAliasId=AGENT_ALIAS_ID,
            sessionId=session_id,
            inputText=message,
            enableTrace=True
        )

        full_response = ""
        last_call_id = None
        active_collaborators = {}  # Track collaborator call IDs

        for event in response['completion']:
            # Handle text chunks
            if 'chunk' in event:
                chunk = event['chunk']
                if 'bytes' in chunk:
                    text = chunk['bytes'].decode('utf-8')
                    full_response += text
                    yield f"data: {json.dumps({'type': 'text_token', 'token': text})}\n\n"

            # Handle trace events
            if 'trace' in event:
                trace = event['trace'].get('trace', {})

                # Get agent alias ID to identify which agent is producing the trace
                agent_alias = event['trace'].get('agentAliasId', AGENT_ALIAS_ID)
                agent_id = event['trace'].get('agentId', AGENT_ID)

                if 'orchestrationTrace' in trace:
                    orch = trace['orchestrationTrace']

                    # Source 1: Rationale field (agent reasoning - most common)
                    if 'rationale' in orch:
                        rationale = orch['rationale']
                        if 'text' in rationale:
                            yield f"data: {json.dumps({'type': 'thinking', 'content': rationale['text'], 'agent_id': agent_id})}\n\n"

                    # Sources 2 & 3: Extract thinking from modelInvocationOutput.rawResponse
                    # This captures: reasoningContent.reasoningText.text AND leading text blocks
                    if 'modelInvocationOutput' in orch:
                        model_output = orch['modelInvocationOutput']
                        if 'rawResponse' in model_output:
                            raw_response = model_output['rawResponse']
                            thinking_texts = extract_thinking_from_raw_response(raw_response)
                            for thinking_text in thinking_texts:
                                yield f"data: {json.dumps({'type': 'thinking', 'content': thinking_text, 'agent_id': agent_id, 'source': 'raw_response'})}\n\n"

                    # Check for sub-agent collaborator invocation
                    if 'invocationInput' in orch:
                        inv_input = orch['invocationInput']

                        # Sub-agent collaborator call (multi-agent)
                        if 'agentCollaboratorInvocationInput' in inv_input:
                            collab = inv_input['agentCollaboratorInvocationInput']
                            collab_name = collab.get('agentCollaboratorName', 'unknown')
                            collab_alias = collab.get('agentCollaboratorAliasArn', '')
                            input_text = collab.get('input', {}).get('text', '')

                            call_id = str(uuid.uuid4())[:8]
                            active_collaborators[collab_alias] = call_id

                            # Emit collaborator_start event (like Bedsheet's delegation)
                            yield f"data: {json.dumps({'type': 'collaborator_start', 'collaborator': collab_name, 'call_id': call_id, 'input': input_text})}\n\n"

                        # Action group tool call (Lambda)
                        elif 'actionGroupInvocationInput' in inv_input:
                            action = inv_input['actionGroupInvocationInput']
                            last_call_id = str(uuid.uuid4())[:8]
                            tool_name = action.get('apiPath', '').strip('/')
                            params = {}
                            for param in action.get('parameters', []):
                                params[param['name']] = param['value']

                            yield f"data: {json.dumps({'type': 'tool_call', 'tool_name': tool_name, 'tool_input': params, 'call_id': last_call_id})}\n\n"

                    # Check for observations (results)
                    if 'observation' in orch:
                        obs = orch['observation']

                        # Sub-agent collaborator result
                        if 'agentCollaboratorInvocationOutput' in obs:
                            collab_output = obs['agentCollaboratorInvocationOutput']
                            collab_name = collab_output.get('agentCollaboratorName', 'unknown')
                            collab_alias = collab_output.get('agentCollaboratorAliasArn', '')
                            output_text = collab_output.get('output', {}).get('text', str(collab_output))

                            call_id = active_collaborators.get(collab_alias, 'unknown')

                            # Emit collaborator_complete event
                            yield f"data: {json.dumps({'type': 'collaborator_complete', 'collaborator': collab_name, 'call_id': call_id, 'result': output_text[:500] + '...' if len(output_text) > 500 else output_text})}\n\n"

                        # Action group tool result
                        elif 'actionGroupInvocationOutput' in obs:
                            output = obs['actionGroupInvocationOutput']
                            result = output.get('text', str(output))
                            yield f"data: {json.dumps({'type': 'tool_result', 'call_id': last_call_id or 'unknown', 'result': result})}\n\n"

        # Emit completion event
        yield f"data: {json.dumps({'type': 'completion', 'response': full_response})}\n\n"

    except Exception as e:
        yield f"data: {json.dumps({'type': 'error', 'error': str(e), 'recoverable': False})}\n\n"


@app.post("/invoke/stream")
async def invoke_stream(request: InvokeRequest):
    """Invoke the Bedrock agent and stream events."""
    session_id = request.session_id or str(uuid.uuid4())

    return StreamingResponse(
        stream_bedrock_events(request.message, session_id),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",
        }
    )


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "healthy", "agent_id": AGENT_ID}


@app.get("/")
async def root():
    """Serve the debug UI."""
    return HTMLResponse(DEBUG_UI_HTML)


# Embedded debug UI (single-file React app)
# Based on Bedsheet local debug UI design
DEBUG_UI_HTML = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wisdom-council - Bedrock Agent Debug UI</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-950 text-white">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useCallback, useRef, useEffect } = React;

        // Helper to truncate strings
        const truncate = (text, maxLength = 50) => {
            if (!text) return '';
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        };

        // Badge styles for event types (matching local debug UI)
        const getBadgeStyles = (eventType) => {
            switch (eventType) {
                case 'tool_call':
                    return { bg: 'bg-blue-900', text: 'text-blue-200', label: String.fromCodePoint(0x1F527) };
                case 'tool_result':
                    return { bg: 'bg-green-900', text: 'text-green-200', label: String.fromCodePoint(0x2713) };
                case 'text_token':
                    return { bg: 'bg-slate-700', text: 'text-slate-300', label: String.fromCodePoint(0x1F4DD) };
                case 'completion':
                    return { bg: 'bg-purple-900', text: 'text-purple-200', label: String.fromCodePoint(0x2714, 0xFE0F) };
                case 'error':
                    return { bg: 'bg-red-900', text: 'text-red-200', label: String.fromCodePoint(0x2717) };
                case 'thinking':
                    return { bg: 'bg-yellow-900', text: 'text-yellow-200', label: String.fromCodePoint(0x1F4AD) };
                case 'collaborator_start':
                case 'collaborator_complete':
                    return { bg: 'bg-orange-900', text: 'text-orange-200', label: String.fromCodePoint(0x2192) };
                case 'session':
                    return { bg: 'bg-slate-700', text: 'text-slate-300', label: String.fromCodePoint(0x25CF) };
                default:
                    return { bg: 'bg-slate-700', text: 'text-slate-300', label: String.fromCodePoint(0x25C6) };
            }
        };

        // Summary for collapsed view
        const getSummary = (event) => {
            switch (event.type) {
                case 'tool_call':
                    return String.fromCodePoint(0x2192) + ' ' + event.tool_name;
                case 'tool_result':
                    if (event.error) return String.fromCodePoint(0x2190) + ' Error: ' + truncate(event.error);
                    const resultStr = typeof event.result === 'string' ? event.result : JSON.stringify(event.result);
                    return String.fromCodePoint(0x2190) + ' ' + truncate(resultStr);
                case 'text_token':
                    return event.token;
                case 'completion':
                    return String.fromCodePoint(0x2713) + ' ' + truncate(event.response);
                case 'error':
                    return String.fromCodePoint(0x2717) + ' ' + truncate(event.error);
                case 'thinking':
                    return String.fromCodePoint(0x1F4AD) + ' ' + truncate(event.content);
                case 'collaborator_start':
                    return String.fromCodePoint(0x2192) + ' ' + event.collaborator + ' starting: ' + truncate(event.input || '');
                case 'collaborator_complete':
                    return String.fromCodePoint(0x2190) + ' ' + event.collaborator + ' done: ' + truncate(event.result || '');
                case 'session':
                    return String.fromCodePoint(0x25CF) + ' Session ' + (event.session_id?.substring(0, 8) || '') + '...';
                default:
                    return 'Event';
            }
        };

        // Check if event can be expanded (text_tokens are inline)
        const canExpand = (event) => event.type !== 'text_token';

        function EventItem({ event, index }) {
            // Start collapsed by default, expand on click
            const [isExpanded, setIsExpanded] = useState(false);
            const badge = getBadgeStyles(event.type);
            const summary = getSummary(event);
            const expandable = canExpand(event);

            // Text tokens render inline without expand
            if (event.type === 'text_token') {
                return (
                    <span className={`text-xs font-mono ${badge.text}`}>
                        {event.token}
                    </span>
                );
            }

            return (
                <div className={`flex items-start gap-2 p-2 rounded border-l-2 border-l-slate-600 ${expandable ? 'cursor-pointer hover:bg-slate-800/50' : ''}`}>
                    {/* Badge */}
                    <div
                        className={`flex-shrink-0 px-2 py-1 rounded text-xs font-semibold whitespace-nowrap ${badge.bg} ${badge.text}`}
                        onClick={() => expandable && setIsExpanded(!isExpanded)}
                    >
                        {badge.label}
                    </div>

                    {/* Content Area */}
                    <div
                        className="flex-1 min-w-0"
                        onClick={() => expandable && setIsExpanded(!isExpanded)}
                    >
                        {!isExpanded ? (
                            // Collapsed view
                            <div className="flex items-center justify-between gap-2">
                                <span className="text-xs truncate text-slate-300">
                                    {summary}
                                </span>
                                {expandable && (
                                    <span className="text-xs text-slate-500 flex-shrink-0">
                                        {isExpanded ? String.fromCodePoint(0x25BE) : String.fromCodePoint(0x25B8)}
                                    </span>
                                )}
                            </div>
                        ) : (
                            // Expanded view
                            <div className="space-y-1">
                                <div className="flex items-center justify-between gap-2 mb-2">
                                    <span className="text-xs font-semibold text-slate-400">
                                        {event.type}
                                    </span>
                                    <button
                                        onClick={(e) => { e.stopPropagation(); setIsExpanded(false); }}
                                        className="text-xs text-slate-500 hover:text-slate-300 transition-colors"
                                    >
                                        {String.fromCodePoint(0x25BE)}
                                    </button>
                                </div>
                                <pre className="text-xs bg-slate-950 p-2 rounded overflow-x-auto border border-slate-700 max-h-64 overflow-y-auto text-slate-200 font-mono whitespace-pre-wrap break-words">
                                    {JSON.stringify(event, null, 2)}
                                </pre>
                            </div>
                        )}
                    </div>

                    {/* Index indicator */}
                    <div className="flex-shrink-0 text-xs text-slate-600 opacity-50">
                        #{index}
                    </div>
                </div>
            );
        }

        function App() {
            const [sessionId, setSessionId] = useState(null);
            const [messages, setMessages] = useState([]);
            const [events, setEvents] = useState([]);
            const [input, setInput] = useState('');
            const [isStreaming, setIsStreaming] = useState(false);
            const [streamingContent, setStreamingContent] = useState('');
            const eventsEndRef = useRef(null);
            const chatEndRef = useRef(null);

            const scrollEventsToBottom = () => {
                eventsEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            };

            const scrollChatToBottom = () => {
                chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            };

            useEffect(() => {
                scrollEventsToBottom();
            }, [events]);

            useEffect(() => {
                scrollChatToBottom();
            }, [messages, streamingContent]);

            const sendMessage = useCallback(async (message) => {
                setMessages(prev => [...prev, { role: 'user', content: message }]);
                setIsStreaming(true);
                setStreamingContent('');

                try {
                    const response = await fetch('/invoke/stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message, session_id: sessionId }),
                    });

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let fullResponse = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split(String.fromCharCode(10) + String.fromCharCode(10));
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const event = JSON.parse(line.substring(6));

                                    if (event.type === 'session') {
                                        setSessionId(event.session_id);
                                        setEvents(prev => [...prev, event]);
                                    } else if (event.type === 'text_token') {
                                        // Text tokens only update chat, not events panel
                                        fullResponse += event.token;
                                        setStreamingContent(fullResponse);
                                    } else if (event.type === 'completion') {
                                        setMessages(prev => [...prev, { role: 'assistant', content: event.response }]);
                                        setStreamingContent('');
                                        setEvents(prev => [...prev, event]);
                                    } else if (event.type === 'error') {
                                        setMessages(prev => [...prev, { role: 'assistant', content: 'Error: ' + event.error }]);
                                        setEvents(prev => [...prev, event]);
                                    } else {
                                        // All other trace events (thinking, tool_call, tool_result, collaborator_*)
                                        setEvents(prev => [...prev, event]);
                                    }
                                } catch (e) {
                                    console.error('Parse error:', e);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Stream error:', error);
                    setMessages(prev => [...prev, { role: 'assistant', content: 'Error: ' + error.message }]);
                } finally {
                    setIsStreaming(false);
                }
            }, [sessionId]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (input.trim() && !isStreaming) {
                    sendMessage(input.trim());
                    setInput('');
                }
            };

            const handleNewSession = () => {
                setSessionId(null);
                setMessages([]);
                setEvents([]);
                setStreamingContent('');
            };

            // Get connection state display
            const getStateDisplay = () => {
                if (isStreaming) return { text: 'streaming', color: 'text-blue-400' };
                return { text: 'idle', color: 'text-slate-500' };
            };
            const stateDisplay = getStateDisplay();

            return (
                <div className="h-screen flex flex-col bg-gray-950">
                    {/* Session Bar */}
                    <div className="bg-slate-800 px-4 py-2 flex items-center justify-between border-b border-slate-700">
                        <div className="flex items-center gap-4">
                            <h1 className="text-sm font-semibold text-slate-200">wisdom-council - Bedrock Debug</h1>
                            <span className="text-xs text-slate-400 font-mono">
                                {sessionId ? 'Session: ' + sessionId.slice(0, 8) + '...' : 'No session'}
                            </span>
                            <span className={`text-xs font-mono ${stateDisplay.color}`}>
                                {stateDisplay.text}
                            </span>
                        </div>
                        <button
                            onClick={handleNewSession}
                            className="px-3 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded text-slate-200 transition-colors"
                        >
                            New Session
                        </button>
                    </div>

                    {/* Main content */}
                    <div className="flex-1 flex overflow-hidden">
                        {/* Chat panel */}
                        <div className="w-1/2 flex flex-col border-r border-slate-700">
                            <div className="flex-1 overflow-y-auto p-4 space-y-3">
                                {messages.map((msg, i) => (
                                    <div key={i} className={msg.role === 'user' ? 'text-right' : ''}>
                                        <div className={`inline-block max-w-[85%] p-3 rounded-lg text-sm ${
                                            msg.role === 'user'
                                                ? 'bg-blue-600 text-white'
                                                : 'bg-slate-800 text-slate-100'
                                        }`}>
                                            <pre className="whitespace-pre-wrap font-sans">{msg.content}</pre>
                                        </div>
                                    </div>
                                ))}
                                {streamingContent && (
                                    <div>
                                        <div className="inline-block max-w-[85%] p-3 rounded-lg bg-slate-800 text-slate-100 text-sm">
                                            <pre className="whitespace-pre-wrap font-sans">{streamingContent}</pre>
                                            <span className="animate-pulse text-blue-400">{String.fromCodePoint(0x258C)}</span>
                                        </div>
                                    </div>
                                )}
                                <div ref={chatEndRef} />
                            </div>
                            <form onSubmit={handleSubmit} className="p-3 border-t border-slate-700 bg-slate-900">
                                <div className="flex gap-2">
                                    <input
                                        type="text"
                                        value={input}
                                        onChange={(e) => setInput(e.target.value)}
                                        placeholder="Type a message..."
                                        disabled={isStreaming}
                                        className="flex-1 px-3 py-2 text-sm bg-slate-800 border border-slate-600 rounded focus:outline-none focus:border-blue-500 text-slate-100 placeholder-slate-500"
                                    />
                                    <button
                                        type="submit"
                                        disabled={isStreaming || !input.trim()}
                                        className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed rounded text-white transition-colors"
                                    >
                                        Send
                                    </button>
                                </div>
                            </form>
                        </div>

                        {/* Events panel */}
                        <div className="w-1/2 flex flex-col bg-slate-900">
                            <div className="px-4 py-2 border-b border-slate-700 flex items-center justify-between bg-slate-800">
                                <h2 className="text-sm font-semibold text-slate-200">Events ({events.length})</h2>
                                <button
                                    onClick={() => setEvents([])}
                                    className="text-xs text-slate-400 hover:text-slate-200 transition-colors"
                                >
                                    Clear
                                </button>
                            </div>
                            <div className="flex-1 overflow-y-auto p-3 space-y-1">
                                {events.map((event, i) => (
                                    <EventItem key={i} event={event} index={i} />
                                ))}
                                <div ref={eventsEndRef} />
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
"""


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)